# 7주차 회고


## 배운 점
### Redis 자료구조
지금까지 현업에서는 Redis 를 캐싱을 하는데 사용만 해보았고, Hash 기능을 사용해본적이 있긴 하지만, "자료구조로써 썼다" 라기 보다는 캐시한다 의 개념에 가까웠음  

Redis 에 여러가지 자료구조가 존재하고 자료구조를 통해 얻을 수 있는 이점이 많다는 것을 알게 됨  
이번에 사용한 Sorted Set 과 Hash 이외에도 여러 자료구조를 추후 학습하여, 추후 현업에서 자료구조를 활용하고 싶음

### TTL 설정기준
일간 랭킹은 24시간으로 설정하였고, 23:50 분에 스케줄러를 동작시켜 덮어씌우는 형식으로 TTL 을 갱신시킴  
이렇게 하므로써 캐시스탬피드 현상을 방지하고, 랭킹도 갱신 할 수 있음

주간 랭킹도 동일하게 24시간 설정. 주간랭킹은 항상 금일 기준 -7 일로 설정하여, 매일매일 갱신되도록 처리 함

### Redis 와 DB 간의 정합성
사실 멘토링을 들으며 전달 받기로, Redis 는 절대로 죽어서는 안되는 instance 라고 설명을 들음    
Redis 는 클러스터로 구성하고, 지역을 나눠서 redis 가 항상 run 하도록 해야함  
redis 가 Down 이 된다면, File 로 저장하고, On 됐을때, 파일을 읽어 데이터를 유지하는 기능도 On 시켜서 최대한 Redis 정보를 유지시켜야 함    
따라서 이번에는 정합성을 크게 신경쓰지 않았고, 쿠폰을 사용 할 때만, coupon issue 에 저장하는 형태로 설계 함

### 이 과제를 통해 배운 Redis 활용의 핵심 인사이트
Redis 를 단순히 캐싱만 하는 제품이 아닌, 자료구조로써, 대용량 트래픽을 위한 뛰어난 설계 도구로써 인식하게 됨  
단순히 캐싱을 하는 것을 넘어, 자료구조를 활용하여, 코드 성능을 극대화 하는 방법을 알게 되었고, 지금 당장 현업에서 쓰긴 어렵겠지만, 대기업을 가서 상당한 트래픽을 받게 된다면, 크게 도움이 될 것이라 생각이 듦

### resilience4j 를 사용한 서킷브레이커
선착순 쿠폰은 제한되어 있기에, 일정이상의 트래픽은 무의미함  
따라서 서킷브레이커를 사용하고, 일정 이상 실패가 발생하면 fallback 함수를 동작시켜 early return 하도록 처리


## 수정이 필요 한 부분
현재 선착순 쿠폰은 원자적이지 못 함. 개발 당시에는 원자성을 띈다고 생각했으나, 코드 리뷰를 받으며 원자성을 띄지 않는것을 확인 함  
따라서 추후 대기열 방식을 사용하던 LUA 스크립트를 사용하건 하여서 원자성을 보장해야 함



## 학습이 필요한 부분
### DDD
이번 과제에서 DDD 패턴이 제대로 정립되어 있지 않아, 매우 힘들었음. 다음 과제를 시작하기 전에, DDD 패턴을 정확히 파악하고 코드에 적용할 필요성이 있음

### DIP
이 개념 또한 제대로 정리가 되어 있지않아, 이번 과제가 매우 힘들었음.  
DIP 를 제대로 이해하고 적용을 했다면, DB 대신 redis 를 사용하도록 Impl 만 변경했어도 됐는데, 사실 그렇게 하지 못 하였음  
이 부분도 시간이 날 때 추후 수정이 필요함.

### POJO(Plain Old Java Object) 도메인
[참고 블로그](https://velog.io/@dion/what-is-POJO)  
특별한 제한에 종속되지 않고, 클래스 패스(class path)를 필요로 하지 않는 일반적인 Java Object를 의미  
조금 더 공부가 필요함

### MSA 아키텍처
[참고 블로그](https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e)  
개념 자체는 알고 있었지만, 용어를 몰랐음

### Root Aggregate (루트 애그리게이트)
- 도메인 객체들의 집합
- 불변성과 일관성을 보장하기 위한 경계를 정의하는 단위


