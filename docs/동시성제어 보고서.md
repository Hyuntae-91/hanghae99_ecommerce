# 동시성 제어 보고서

## 동시성 이슈 발생
본 프로젝트는 이커머스를 기반으로 한 시스템입니다.  
동일한 상품이나 자원(예: 재고, 포인트 등)에 대해  
여러 사용자가 동시에 접근하는 상황이 빈번하게 발생합니다.

특히 한정 재고 상품, 포인트 차감, 선착순 쿠폰, 결제 등의 기능은  
실시간으로 요청이 몰려 트랜잭션 충돌의 위험이 큽니다.

이 프로젝트에서도 아래와 같은 동시성 문제가 실제로 발생하였습니다.


### Race Condition
- 두 개 이상의 결제 요청이 동시에 들어옴
- 같은 상품의 재고를 **거의 동시에** 조회 후 차감 시도
- 특정 사용자의 포인트 데이터를 **거의 동시에** 조회 후 차감 시도

### 데이터 무결성 오류
- 재고가 한정된 상품에 다수의 요청이 들어와 재고 이상의 상품 결제가 성공
- 1000원짜리 물건을 1000원을 가진 유저가 동시에 여러번 결제 시도시, 여러개의 제품이 구입 됨


## 문제 식별
4주차 동시성 테스트 작성으로 발생할 수 있는 동시성 이슈파악은 이미 되었음
- 유저 포인트
  - 포인트를 동시에 충전 / 차감
- 쿠폰
  - 선착순 쿠폰에 여러 유저가 동시에 발급 시도
  - 유저가 쿠폰 하나를 여러번 동시에 사용 시도
- 주문 / 결제
  - 한정된 재고 상품에 여러명의 유저가 동시에 구매 시도
  - 한 유저가 동시에 여러번 결제 시도


## 분석
### 1. 동시성 이슈의 주 원인
- 공유 자원에 대한 동시 접근
  - 포인트, 재고, 쿠폰은 여러 트랜잭션에서 동시에 접근이 가능함
  - 트랜잭션 격리 수준이 낮거나 Lock 제어가 없다면 race condition 이 발생함

### 2. 실제 발생한 시나리오 별 분석
- 유저 포인트 충전 / 차감
  - 충전 / 차감 : 동시에 여러 Thread 가 UserPoint 객체를 조회하고 Charge() / use() 함수 호출
  - 동시에 접근시, race condition 과 데이터 무결성 오류 발생
- 선착순 쿠폰
  - 쿠폰의 수량이 정해진 동일한 쿠폰에 대해 여러 사용자가 동시에 발급 요청
  - 남은 수량은 쿠폰의 quantity 컬럼으로 판단되는데, 동시에 증가 연산이 수행되면 중복 발급됨
- 한정된 재고 상품
  - 재고가 한정된 (예를 들면 1개) 상품에 10명이 동시에 결제 시도
  - 재고의 경우 OrderOptions 의 Quantity 로 관리중인데, 동시에 조회 및 차감 시도
  - 조회 당시 남은 재고수 1개를 여러 thread 가 동시에 식별, 문제없이 결제까지 진행됨
- 따닥이슈 혹은 악의적으로 한 유저가 동시에 특정 결제를 시도함
  - 결제는 유저 포인트 차감, 쿠폰 사용, 재고 차감 로직등이 동시에 이뤄짐
  - 위의 동시성이슈가 동시다발적으로 어디에선가 발생할 수 있음

### 3. 발생 이슈 요약
| 이슈 유형 | 원인 | 영향 |
|-------|-----|-----|
| Lost Update | 동시에 저장된 값이 서로 덮어씀 | 잘못된 포인트, 재고, 쿠폰발급 발생|
| Dirty Read | 롤백된 데이터 참조 | 임시 결과를 기반으로 처리 |
| Non-repeatable read | 조회 후 변경 발생 | 일관성 없는 상태 |


## 해결

### 1. 낙관적 락 (Optimistic Lock)
Lock Controller 을 더 편하게 적용하기 위해서 @OptimisticRetry 데코레이터를 AOP 에 정의  
src.main.java.kr.hhplus.be.server.common 안에 정의됨  
낙관적 락이 필요한 메소드에 데코레이터만 @Transactional 처럼 적용하면 됨  
retry 로직 또한 동시에 추가하여, 일정 횟수 retry 를 시도하여 동시성을 제어하고자 함  
예외 발생시 지수 백오프 적용으로 성능 보호

- 적용 대상 : 유저 포인트 충전/차감, 쿠폰 사용
- 적용 이유
  - 유저 포인트는 특정 유저에게만 종속된 데이터 
  - 쿠폰은 한 유저에 종속된 데이터
  - 악의적인 공격이 아닌이상, 포인트나 쿠폰을 동시에 사용하는 이슈는 많이 발생하지 않을 것임

#### 적용 방식
```java
@Version
private Long version;
```
도메인 엔티티에 위 필드를 추가 및 DB 테이블에도 version 컬럼 추가

#### 효과
- DB 레벨의 lock 이 없어도 version 이 업데이트를 방어하면서, 정합성을 보장
- 충돌 발생 시 선입 선처리 방식으로 순차적 성공 가능

### 비관적 락
- 적용 대상 : 재고 차감, 선착순 쿠폰
- 적용 이유
  - 재고 차감은 정확한 여러 유저가 동시에 접근하며, 정확한 재고관리가 요구됨
  - 선착순 쿠폰도 여러 유저가 동시에 접근 하며, 정확한 쿠폰 발급이 요구됨

#### 적용 방식
- @Lock(LockModeType,PERSSIMISTIC_WRITE) 사용
    - 내부적으로는 SELECT ... FOR UPDATE 형태로 트랜잭션 간 베타적 접근 제어

#### 효과
- 재고 감소가 확정되기 전까지 타 트랜잭션 접근 차단
- 높은 정확성이 필요하고, 다수의 트랜잭션이 접근한다고 가정되는 로직에 적합


# 추가로 고민해볼 점
1. 낙관적 락 vs 비관적 락
- 단순히 봤을때는 낙관적 락이 성능이 좋을것으로 보임
- 실질적으로 큰 차이가 없으며, 결국에는 락에 대한 성능 저하는 동일하게 발생
- 네트워크 환경에서는 오히려 낙관적 락이 성능이 떨어질 수 있음
  - 낙관적 락은 앱 서비스단에서 DB 로 직접 retry 요청 처리
  - retry 시도시마다, DB 와 통신 비용 발생
  - 비관적 락은 lock 자체를 DB 안에서 대기하므로, 네트워크 비용이 발생하지 않음
    - 오히려 성능 상승
2. 낙관적락은 사실상 동시성 이슈가 발생하지 않는다고 가정
   - 만에하나를 대비하는 락임
   - 낙관적락이 자주 발생한다면 차라리 비관적 락으로 전환하는것을 생각
3. 추후에는 이벤트 발생으로 transaction 을 나누고, 롤백을 구현하는 방식으로 성능을 끌어올리는 방법이 있음